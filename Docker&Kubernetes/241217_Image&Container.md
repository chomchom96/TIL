### 정의

- 이미지는 컨테이너를 위한 Template/Blueprint
    - 실제 코드와 코드 실행을 위한 도구 & runtime 포함한 공유 가능한 패키지
    - 이미지를 기반으로 여러 컨테이너를 재생성할 수 있음
- 컨테이너는 이미지 기반 실행 인스턴스

### 외부 이미지 사용 & 실행

- https://hub.docker.com/ →  공식 이미지 검색
- CLI에서 검색 수 해당 이미지 pull

```jsx
node -> docker run node
```

- run시 이미지가 없을 경우 pull 후 실행
- 컨테이너는 외부와 격리되어 있으며 실행중인 내부 shell이 있더라도 외부에 노출되지 않음

```jsx
docker ps -a -> docker가 실행하는 모든(-a) 프로세스(ps) 표시
docker run -it code -> 컨테이너 내부에서 interactive 세션 노출, 이후 node terminal 접근할 수 있음
```

### NodeJS 앱 Dockerfile로 빌드

- Node가 아니더라도 일반적인 경우 언어에 맞는 공식 Image를 가져온 다음 해당 어플리케이션 실행
- pull 이미지 기반으로 자체 이미지 만들기
- Docker extension 설치 후 Dockerfile 파일 생성
    - Docker에게 이미지 빌드 시 실행할 명령 지정’
    - FROM부터 시작 → 다른 베이스 이미지 기반으로 생성 가능하게 함
    - 

```docker
FROM node
# 이미지에 들어갈 파일 copy
# 가장 쉬운 방법은 copy . . -> Dockefile 포함된 모든 하위 파일 복사
# .은 전체 지정
# 모든 컨테이너는 로컬 파일 시스템과 분리된 자체 내부 시스템을 가짐
# 기본값으로 실행되는 위치는 파일 시스템의 루트 폴더
# 서브폴더를 사용하고 있으므로 실행되는 위치(WORKDIR)를 지정
WORKDIR /app
# 예를 들어 app이라 지정하면 app이라는 하위 폴더를 생성해 사용
COPY . /app
# 또는 지정 디렉토리를 사용
COPY . ./
# node 자체 빌드 명령
RUN npm install
# 이미지는 컨테이너의 탬플릿임
# 이미지를 기반으로 여러 컨테이너를 실행하면 RUN으로 서버를 열 경우
# 하나의 어플리케이션에 대해 여러 서버를 실행함 -> 의도와 맞지 않음 
# RUN node server.js -> X
# 애플리케이션은 포트 80번 listen
# 컨테이너 내부의 어플리케이션에서 사용하므로 컨테이너의 포트 80을 열어야 함
# CMD 전에 지정할 것
EXPOSE 80
# CMD로 명령어를 지정하면 이미지가 생성될 때 말고 이미지 기반으로 컨테이너 시작 시 실행
# 배열로 커맨드 전달
CMD ["node", "server.js"]
```

### 자체 이미지 기반 컨테이너 실행

- Dockerfile 생성 후 컨테이너 실행하ㅣㄱ

```docker
// CLI
# build cmd로 커스텀 이미지 빌드 + 위치 지정
# . -> dockerfile과 동일한 위치
docker build .
```

- docker에서 포트를 노출했지만 접속이 아직 안 됨
- 기존 컨테이너 종료하기
    - 새로운 터미널에서 docker ps (실행중인 프로세스만 보기)
    
    → 방금 실행한 컨테이너 실행 중
    
- docker stop <이름> → 종료
- 포트의 문제 → EXPOSE 80은 doc 목적으로는 있지만 실제로 실행되진 않음
    - 컨테이너를 docker run으로 실행 시 옵션을 추가해야 함

```docker
docker run -p 3000:80 <이름>
# publish로 컨테이너의 해당 포트와 연결할 로컬 포트 설정
```

### EXPOSE

> 결국 Dockerfile의 '`EXPOSE 80`'은 선택 사항이라는 점을 다시 한 번 명확히 하고 싶습니다. 그것은 컨테이너의 프로세스가 이 포트를 노출할 것임을 **문서화**하는 겁니다. 하지만 '`docker run`'을 실행할 때 '`-p`'를 사용하여 실제로 포트를 노출해야 합니다. 따라서 기술적으로 '`-p`'는 포트에서 수신 대기할 때 **유일하게 필요한 부분**입니다. 하지만 Dockerfile에 'EXPOSE'를 추가하여 이 동작을 문서화하는 것이 **모범적인 사용법**입니다.
> 
> 
> 추가 **참고 사항**: **ID**를 사용할 수 있는 모든 **docker 명령**의 경우, **항상 전체 ID를 복사**/기록할 필요는 **없습니다**.
> 
> 첫 번째(몇 개) 문자를 사용할 수도 있습니다. 고유 식별자를 갖는 것만으로도 충분합니다.
> 
> 그래서
> `1. docker run abcdefg`
> 
> 이 명령 대신
> 
> `1. docker run abc`
> 
> 이 명령을 실행할 수도 있습니다.
> 
> 또는 "a"로 시작하는 다른 이미지 ID가 없으면, 다음과 같은 명령을 실행할 수도 있습니다.
> 
> `1. docker run a`
> 
> **이는 ID를 필요로 하는 모든 Docker 명령어에 적용됩니다.**
> 

### 이미지는 read only

- 파일을 변경 후 컨테이너를 다시 실행하면 변경점이 적용이 되지 않은 것을 확인할 수 있음
    - 서버 파일을 모두 COPY후 컨테이너의 파일 시스템에 저장했음
    - 복사 시정에서 소스 코드의 스냅샷을 생성 후 사용
    - 소스 코드를 편집하더라도 소스 코드에 반영되지 않으므로 rebuild 필요
        - docker build .
        - 새로운 이미지가 생성되므로 이름이 바뀜

### 이미지 레이어

- 이미지를 빌드하면 명령이 실행 후 이미지가 닫힘 → 업데이트를 위해 새로 빌드
- 변경 없이 빌드를 다시 실행하면 빠르게 끝남 → use cache, 캐시 기반으로 이전과 파일이 동일함을 확인 후 실제로 빌드할 필요가 없다고 판단
- Docker는 모든 명령을 cache → Layer based architecture
- 이미지는 레이어 기반(Layer-based)
    - 이미지의 모든 명령은 하나의 Layer
    - 이미지는 여러 명령이 Image Layer가 되어 구성됨
    - 이미지 기반 컨테이너를 실행하면 컨테이너는 실행 중인 어플리케이션 위에 최종 레이어(Container Layer) 생성 → read & write
        - 최종 명령 이전의 모든 명령은 이미지의 일부이나 별도의 레이어
        - 아무것도 변경되지 않으면 이전 레이어를 캐시에서 사용
    - 하나의 레이어가 변경된 후 변경 레이어 위의 모든 레이어가 변경됨
        - Docker는 파일이 변경될 경우 어떤 파일이 어디서 변경되었는지 심층 분석을 하지 않음
        - 따라서 변경 레이어 위의 모든 레이어를 다시 실행 후 평가
        - 위의 Dockerfile에서 파일을 변경하면 COPY 다음 레이어인 npm install도 다시 실행됨(package.json의 변경이 없음에도)
        
        → 최적화를 위해 package.json copy 후 npm i, 소스코드 복사로 개선
        
    -
